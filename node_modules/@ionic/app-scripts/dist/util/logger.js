"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var events_1 = require('./events');
var path_1 = require('path');
var config_1 = require('./config');
var fs_extra_1 = require('fs-extra');
var chalk = require('chalk');
var BuildError = (function (_super) {
    __extends(BuildError, _super);
    function BuildError(err) {
        _super.call(this);
        this.hasBeenLogged = false;
        if (err) {
            if (err.message) {
                this.message = err.message;
            }
            else if (err) {
                this.message = err;
            }
            if (err.stack) {
                this.stack = err.stack;
            }
            if (err.name) {
                this.name = err.name;
            }
            if (typeof err.hasBeenLogged === 'boolean') {
                this.hasBeenLogged = err.hasBeenLogged;
            }
        }
    }
    BuildError.prototype.toJson = function () {
        return {
            message: this.message,
            name: this.name,
            stack: this.stack,
            hasBeenLogged: this.hasBeenLogged
        };
    };
    return BuildError;
}(Error));
exports.BuildError = BuildError;
/* There are special cases where strange things happen where we don't want any logging, etc.
 * For our sake, it is much easier to get off the happy path of code and just throw an exception
 * and do nothing with it
 */
var IgnorableError = (function (_super) {
    __extends(IgnorableError, _super);
    function IgnorableError(msg) {
        _super.call(this, msg);
    }
    return IgnorableError;
}(Error));
exports.IgnorableError = IgnorableError;
var Logger = (function () {
    function Logger(scope) {
        this.start = Date.now();
        this.scope = scope;
        var msg = scope + " started " + chalk.dim('...');
        if (config_1.isDebugMode()) {
            msg += memoryUsage();
        }
        Logger.info(msg);
        var taskEvent = {
            scope: this.scope.split(' ')[0],
            type: 'start',
            msg: scope + " started ..."
        };
        events_1.emit(events_1.EventType.TaskEvent, taskEvent);
    }
    Logger.prototype.ready = function (chalkColor) {
        this.completed('ready', chalkColor);
    };
    Logger.prototype.finish = function (chalkColor) {
        this.completed('finished', chalkColor);
    };
    Logger.prototype.completed = function (type, chalkColor) {
        var taskEvent = {
            scope: this.scope.split(' ')[0],
            type: type
        };
        taskEvent.duration = Date.now() - this.start;
        if (taskEvent.duration > 1000) {
            taskEvent.time = 'in ' + (taskEvent.duration / 1000).toFixed(2) + ' s';
        }
        else {
            var ms = parseFloat((taskEvent.duration).toFixed(3));
            if (ms > 0) {
                taskEvent.time = 'in ' + taskEvent.duration + ' ms';
            }
            else {
                taskEvent.time = 'in less than 1 ms';
            }
        }
        taskEvent.msg = this.scope + " " + taskEvent.type + " " + taskEvent.time;
        events_1.emit(events_1.EventType.TaskEvent, taskEvent);
        var msg = this.scope + " " + type;
        if (chalkColor) {
            msg = chalkColor(msg);
        }
        msg += ' ' + chalk.dim(taskEvent.time);
        if (config_1.isDebugMode()) {
            msg += memoryUsage();
        }
        Logger.info(msg);
    };
    Logger.prototype.fail = function (err) {
        if (err) {
            if (err instanceof IgnorableError) {
                return;
            }
            // only emit the event if it's a valid error
            var taskEvent = {
                scope: this.scope.split(' ')[0],
                type: 'failed',
                msg: this.scope + ' failed'
            };
            events_1.emit(events_1.EventType.TaskEvent, taskEvent);
            if (err instanceof BuildError) {
                var failedMsg = this.scope + " failed";
                if (err.message) {
                    failedMsg += ": " + err.message;
                }
                if (!err.hasBeenLogged) {
                    Logger.error("" + failedMsg);
                    err.hasBeenLogged = true;
                    if (err.stack && config_1.isDebugMode()) {
                        Logger.debug(err.stack);
                    }
                }
                else if (config_1.isDebugMode()) {
                    Logger.debug("" + failedMsg);
                }
                return err;
            }
        }
        return err;
    };
    /**
     * Does not print out a time prefix or color any text. Only prefix
     * with whitespace so the message is lined up with timestamped logs.
     */
    Logger.log = function () {
        var msg = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            msg[_i - 0] = arguments[_i];
        }
        Logger.wordWrap(msg).forEach(function (line) {
            console.log(line);
        });
    };
    /**
     * Prints out a dim colored timestamp prefix.
     */
    Logger.info = function () {
        var msg = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            msg[_i - 0] = arguments[_i];
        }
        var lines = Logger.wordWrap(msg);
        if (lines.length) {
            var prefix = timePrefix();
            lines[0] = chalk.dim(prefix) + lines[0].substr(prefix.length);
        }
        lines.forEach(function (line) {
            console.log(line);
        });
    };
    /**
     * Prints out a yellow colored timestamp prefix.
     */
    Logger.warn = function () {
        var msg = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            msg[_i - 0] = arguments[_i];
        }
        var lines = Logger.wordWrap(msg);
        if (lines.length) {
            var prefix = timePrefix();
            lines[0] = prefix + lines[0].substr(prefix.length);
        }
        lines.forEach(function (line) {
            console.warn(chalk.yellow(line));
        });
    };
    /**
     * Prints out a error colored timestamp prefix.
     */
    Logger.error = function () {
        var msg = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            msg[_i - 0] = arguments[_i];
        }
        var lines = Logger.wordWrap(msg);
        if (lines.length) {
            var prefix = timePrefix();
            lines[0] = prefix + lines[0].substr(prefix.length);
            if (config_1.isDebugMode()) {
                lines[0] += memoryUsage();
            }
        }
        lines.forEach(function (line) {
            console.error(chalk.red(line));
        });
    };
    /**
     * Prints out a blue colored DEBUG prefix. Only prints out when debug mode.
     */
    Logger.debug = function () {
        var msg = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            msg[_i - 0] = arguments[_i];
        }
        if (config_1.isDebugMode()) {
            msg.push(memoryUsage());
            var lines = Logger.wordWrap(msg);
            if (lines.length) {
                var prefix = '[ DEBUG! ]';
                lines[0] = prefix + lines[0].substr(prefix.length);
            }
            lines.forEach(function (line) {
                console.log(chalk.cyan(line));
            });
        }
    };
    Logger.printDiagnostic = function (d) {
        if (d.level === 'warn') {
            Logger.warn(d.header);
        }
        else {
            Logger.error(d.header);
        }
        Logger.wordWrap([d.messageText]).forEach(function (m) {
            console.log(m);
        });
        Logger.newLine();
        if (d.lines && d.lines.length) {
            Logger.removeWhitespaceIndent(d.lines);
            d.lines.forEach(function (l) {
                var msg = 'L' + l.lineNumber + ':  ';
                while (msg.length < Logger.INDENT.length) {
                    msg = ' ' + msg;
                }
                if (l.errorCharStart > -1) {
                    l.text = Logger.highlightError(l.text, l.errorCharStart, l.errorLength);
                }
                msg = chalk.dim(msg);
                if (d.syntax === 'js') {
                    msg += Logger.jsSyntaxHighlight(l.text);
                }
                else if (d.syntax === 'css') {
                    msg += Logger.cssSyntaxHighlight(l.text, l.errorCharStart);
                }
                else {
                    msg += l.text;
                }
                console.log(msg);
            });
            Logger.newLine();
        }
    };
    Logger.highlightError = function (errorLine, errorCharStart, errorLength) {
        var rightSideChars = errorLine.length - errorCharStart + errorLength - 1;
        while (errorLine.length + Logger.INDENT.length > Logger.MAX_LEN) {
            if (errorCharStart > (errorLine.length - errorCharStart + errorLength) && errorCharStart > 5) {
                // larger on left side
                errorLine = errorLine.substr(1);
                errorCharStart--;
            }
            else if (rightSideChars > 1) {
                // larger on right side
                errorLine = errorLine.substr(0, errorLine.length - 1);
                rightSideChars--;
            }
            else {
                break;
            }
        }
        var lineChars = [];
        var lineLength = Math.max(errorLine.length, errorCharStart + errorLength);
        for (var i = 0; i < lineLength; i++) {
            var chr = errorLine.charAt(i);
            if (i >= errorCharStart && i < errorCharStart + errorLength) {
                chr = chalk.bgRed(chr === '' ? ' ' : chr);
            }
            lineChars.push(chr);
        }
        return lineChars.join('');
    };
    Logger.removeWhitespaceIndent = function (lines) {
        for (var i = 0; i < 100; i++) {
            if (!eachLineHasLeadingWhitespace(lines)) {
                return;
            }
            for (var i = 0; i < lines.length; i++) {
                lines[i].text = lines[i].text.substr(1);
                lines[i].errorCharStart--;
                if (!lines[i].text.length) {
                    return;
                }
            }
        }
    };
    Logger.wordWrap = function (msg) {
        var output = [];
        var words = [];
        msg.forEach(function (m) {
            if (m === null) {
                words.push('null');
            }
            else if (typeof m === 'undefined') {
                words.push('undefined');
            }
            else if (typeof m === 'string') {
                m.replace(/\s/gm, ' ').split(' ').forEach(function (strWord) {
                    if (strWord.trim().length) {
                        words.push(strWord.trim());
                    }
                });
            }
            else if (typeof m === 'number' || typeof m === 'boolean') {
                words.push(m.toString());
            }
            else if (typeof m === 'function') {
                words.push(m.toString());
            }
            else if (Array.isArray(m)) {
                words.push(function () {
                    return m.toString();
                });
            }
            else if (Object(m) === m) {
                words.push(function () {
                    return m.toString();
                });
            }
            else {
                words.push(m.toString());
            }
        });
        var line = Logger.INDENT;
        words.forEach(function (word) {
            if (typeof word === 'function') {
                if (line.trim().length) {
                    output.push(line);
                }
                output.push(word());
                line = Logger.INDENT;
            }
            else if (Logger.INDENT.length + word.length > Logger.MAX_LEN) {
                // word is too long to play nice, just give it its own line
                if (line.trim().length) {
                    output.push(line);
                }
                output.push(Logger.INDENT + word);
                line = Logger.INDENT;
            }
            else if ((word.length + line.length) > Logger.MAX_LEN) {
                // this word would make the line too long
                // print the line now, then start a new one
                output.push(line);
                line = Logger.INDENT + word + ' ';
            }
            else {
                line += word + ' ';
            }
        });
        if (line.trim().length) {
            output.push(line);
        }
        return output;
    };
    Logger.meaningfulLine = function (line) {
        if (line) {
            line = line.trim();
            if (line.length) {
                return (MEH_LINES.indexOf(line) < 0);
            }
        }
        return false;
    };
    Logger.jsSyntaxHighlight = function (text) {
        if (text.trim().startsWith('//')) {
            return chalk.dim(text);
        }
        var words = text.split(' ').map(function (word) {
            if (JS_KEYWORDS.indexOf(word) > -1) {
                return chalk.cyan(word);
            }
            return word;
        });
        return words.join(' ');
    };
    Logger.cssSyntaxHighlight = function (text, errorCharStart) {
        var cssProp = true;
        var safeChars = 'abcdefghijklmnopqrstuvwxyz-_';
        var notProp = '.#,:}@$[]/*';
        var chars = [];
        for (var i = 0; i < text.length; i++) {
            var c = text.charAt(i);
            if (c === ';' || c === '{') {
                cssProp = true;
            }
            else if (notProp.indexOf(c) > -1) {
                cssProp = false;
            }
            if (cssProp && safeChars.indexOf(c.toLowerCase()) > -1) {
                chars.push(chalk.cyan(c));
                continue;
            }
            chars.push(c);
        }
        return chars.join('');
    };
    Logger.formatFileName = function (rootDir, fileName) {
        fileName = fileName.replace(rootDir, '');
        if (/\/|\\/.test(fileName.charAt(0))) {
            fileName = fileName.substr(1);
        }
        if (fileName.length > 80) {
            fileName = '...' + fileName.substr(fileName.length - 80);
        }
        return fileName;
    };
    Logger.formatHeader = function (task, fileName, rootDir, startLineNumber, endLineNumber) {
        if (startLineNumber === void 0) { startLineNumber = null; }
        if (endLineNumber === void 0) { endLineNumber = null; }
        var header = task + ": ";
        fileName = Logger.formatFileName(rootDir, fileName);
        if (startLineNumber !== null && startLineNumber > 0) {
            header += fileName + ', ';
            if (endLineNumber !== null && endLineNumber > startLineNumber) {
                header += "lines: " + startLineNumber + " - " + endLineNumber;
            }
            else {
                header += "line: " + startLineNumber;
            }
        }
        return header;
    };
    Logger.newLine = function () {
        console.log('');
    };
    Logger.INDENT = '            ';
    Logger.MAX_LEN = 120;
    return Logger;
}());
exports.Logger = Logger;
function eachLineHasLeadingWhitespace(lines) {
    if (!lines.length) {
        return false;
    }
    for (var i = 0; i < lines.length; i++) {
        if (lines[i].text.length < 1) {
            return false;
        }
        var firstChar = lines[i].text.charAt(0);
        if (firstChar !== ' ' && firstChar !== '\t') {
            return false;
        }
    }
    return true;
}
function timePrefix() {
    var date = new Date();
    return '[' + ('0' + date.getHours()).slice(-2) + ':' + ('0' + date.getMinutes()).slice(-2) + ':' + ('0' + date.getSeconds()).slice(-2) + ']';
}
function memoryUsage() {
    return chalk.dim(" MEM: " + (process.memoryUsage().rss / 1000000).toFixed(1) + "MB");
}
function getAppScriptsVersion() {
    var rtn = '';
    try {
        var packageJson = fs_extra_1.readJSONSync(path_1.join(__dirname, '..', '..', 'package.json'));
        rtn = packageJson.version || '';
    }
    catch (e) { }
    return rtn;
}
exports.getAppScriptsVersion = getAppScriptsVersion;
var JS_KEYWORDS = [
    'as',
    'break',
    'case',
    'catch',
    'class',
    'const',
    'continue',
    'debugger',
    'default',
    'delete',
    'do',
    'else',
    'export',
    'extends',
    'finally',
    'for',
    'from',
    'function',
    'if',
    'import',
    'in',
    'instanceof',
    'new',
    'return',
    'super',
    'switch',
    'this',
    'throw',
    'try',
    'typeof',
    'var',
    'void',
    'while',
];
var MEH_LINES = [';', ':', '{', '}', '(', ')', '/**', '/*', '*/', '*', '({', '})'];
