"use strict";
var fs_1 = require('fs');
var logger_1 = require('./util/logger');
var config_1 = require('./util/config');
var path_1 = require('path');
var tslint_1 = require('tslint');
var logger_tslint_1 = require('./util/logger-tslint');
var worker_client_1 = require('./worker-client');
var Linter = require('tslint');
var fs = require('fs');
function lint(context, configFile) {
    context = config_1.generateContext(context);
    return worker_client_1.runWorker('lint', 'lintWorker', context, configFile)
        .catch(function (err) {
        throw new logger_1.BuildError(err);
    });
}
exports.lint = lint;
function lintWorker(context, configFile) {
    var logger = new logger_1.Logger('lint');
    return getLintConfig(context, configFile).then(function (configFile) {
        // there's a valid tslint config, let's continue
        return lintApp(context, configFile);
    }).then(function () {
        // always finish and resolve
        logger.finish();
    }).catch(function () {
        // always finish and resolve
        logger.finish();
    });
}
exports.lintWorker = lintWorker;
function lintUpdate(event, filePath, context) {
    return new Promise(function (resolve) {
        // throw this in a promise for async fun, but don't let it hang anything up
        var workerConfig = {
            configFile: config_1.getUserConfigFile(context, taskInfo, null),
            filePath: filePath
        };
        worker_client_1.runWorker('lint', 'lintUpdateWorker', context, workerConfig);
        resolve();
    });
}
exports.lintUpdate = lintUpdate;
function lintUpdateWorker(context, workerConfig) {
    return getLintConfig(context, workerConfig.configFile).then(function (configFile) {
        // there's a valid tslint config, let's continue (but be quiet about it!)
        var program = tslint_1.createProgram(configFile, context.srcDir);
        return lintFile(context, program, workerConfig.filePath);
    }).catch(function () {
    });
}
exports.lintUpdateWorker = lintUpdateWorker;
function lintApp(context, configFile) {
    var program = tslint_1.createProgram(configFile, context.srcDir);
    var files = tslint_1.getFileNames(program);
    var promises = files.map(function (file) {
        return lintFile(context, program, file);
    });
    return Promise.all(promises);
}
function lintFile(context, program, filePath) {
    return new Promise(function (resolve) {
        if (isMpegFile(filePath)) {
            // silly .ts files actually being video files
            resolve();
            return;
        }
        fs.readFile(filePath, 'utf8', function (err, contents) {
            if (err) {
                // don't care if there was an error
                // let's just move on with our lives
                resolve();
                return;
            }
            try {
                var configuration = tslint_1.findConfiguration(null, filePath);
                var linter = new Linter(filePath, contents, {
                    configuration: configuration,
                    formatter: null,
                    formattersDirectory: null,
                    rulesDirectory: null,
                }, program);
                var lintResult = linter.lint();
                if (lintResult && lintResult.failures) {
                    logger_tslint_1.runDiagnostics(context, lintResult.failures);
                }
            }
            catch (e) {
                logger_1.Logger.debug("Linter " + e);
            }
            resolve();
        });
    });
}
function getLintConfig(context, configFile) {
    return new Promise(function (resolve, reject) {
        configFile = config_1.getUserConfigFile(context, taskInfo, configFile);
        if (!configFile) {
            configFile = path_1.join(context.rootDir, 'tslint.json');
        }
        logger_1.Logger.debug("tslint config: " + configFile);
        fs_1.access(configFile, function (err) {
            if (err) {
                // if the tslint.json file cannot be found that's fine, the
                // dev may not want to run tslint at all and to do that they
                // just don't have the file
                reject();
                return;
            }
            resolve(configFile);
        });
    });
}
function isMpegFile(file) {
    var buffer = new Buffer(256);
    buffer.fill(0);
    var fd = fs.openSync(file, 'r');
    try {
        fs.readSync(fd, buffer, 0, 256, null);
        if (buffer.readInt8(0) === 0x47 && buffer.readInt8(188) === 0x47) {
            logger_1.Logger.debug("tslint: " + file + ": ignoring MPEG transport stream");
            return true;
        }
    }
    finally {
        fs.closeSync(fd);
    }
    return false;
}
var taskInfo = {
    fullArgConfig: '--tslint',
    shortArgConfig: '-i',
    envConfig: 'ionic_tslint',
    defaultConfigFile: '../tslint'
};
