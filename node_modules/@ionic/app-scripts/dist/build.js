"use strict";
var logger_1 = require('./util/logger');
var bundle_1 = require('./bundle');
var clean_1 = require('./clean');
var copy_1 = require('./copy');
var config_1 = require('./util/config');
var lint_1 = require('./lint');
var minify_1 = require('./minify');
var ngc_1 = require('./ngc');
var sass_1 = require('./sass');
var transpile_1 = require('./transpile');
function build(context) {
    context = config_1.generateContext(context);
    var logger = new logger_1.Logger("build " + (context.isProd ? 'prod' : 'dev'));
    return buildWorker(context)
        .then(function () {
        // congrats, we did it!  (•_•) / ( •_•)>⌐■-■ / (⌐■_■)
        context.fullBuildCompleted = true;
        logger.finish();
    })
        .catch(function (err) {
        throw logger.fail(err);
    });
}
exports.build = build;
function buildWorker(context) {
    if (context.isProd) {
        // production build
        return buildProd(context);
    }
    // dev build
    return buildDev(context);
}
function buildProd(context) {
    // sync empty the www/build directory
    clean_1.clean(context);
    // async tasks
    // these can happen all while other tasks are running
    var copyPromise = copy_1.copy(context);
    var lintPromise = lint_1.lint(context);
    // kick off ngc to run the Ahead of Time compiler
    return ngc_1.ngc(context)
        .then(function () {
        // ngc has finished, now let's bundle it all together
        return bundle_1.bundle(context);
    })
        .then(function () {
        // js minify can kick off right away
        var jsPromise = minify_1.minifyJs(context);
        // sass needs to finish, then css minify can run when sass is done
        var sassPromise = sass_1.sass(context)
            .then(function () {
            return minify_1.minifyCss(context);
        });
        return Promise.all([
            jsPromise,
            sassPromise
        ]);
    })
        .then(function () {
        // ensure the async tasks have fully completed before resolving
        return Promise.all([
            copyPromise,
            lintPromise
        ]);
    })
        .catch(function (err) {
        throw new logger_1.BuildError(err);
    });
}
function buildDev(context) {
    // sync empty the www/build directory
    clean_1.clean(context);
    // async tasks
    // these can happen all while other tasks are running
    var copyPromise = copy_1.copy(context);
    var lintPromise = lint_1.lint(context);
    // just bundle, and if that passes then do the rest at the same time
    return transpile_1.transpile(context)
        .then(function () {
        return bundle_1.bundle(context);
    })
        .then(function () {
        return Promise.all([
            sass_1.sass(context),
            copyPromise,
            lintPromise
        ]);
    })
        .catch(function (err) {
        throw new logger_1.BuildError(err);
    });
}
function fullBuildUpdate(event, filePath, context) {
    return buildUpdateWorker(event, filePath, context, true).then(function () {
        context.fullBuildCompleted = true;
    });
}
exports.fullBuildUpdate = fullBuildUpdate;
function buildUpdate(event, filePath, context) {
    return buildUpdateWorker(event, filePath, context, false);
}
exports.buildUpdate = buildUpdate;
function buildUpdateWorker(event, filePath, context, fullBuild) {
    var logger = new logger_1.Logger("build update");
    var transpilePromise = null;
    if (fullBuild) {
        transpilePromise = transpile_1.transpile(context);
    }
    else {
        transpilePromise = transpile_1.transpileUpdate(event, filePath, context);
    }
    return transpilePromise
        .then(function () {
        if (fullBuild) {
            return bundle_1.bundle(context);
        }
        return bundle_1.bundleUpdate(event, filePath, context);
    }).then(function () {
        if (fullBuild) {
            return sass_1.sass(context);
        }
        else if (event !== 'change' || !context.successfulSass) {
            // if just the TS file changed, then there's no need to do a sass update
            // however, if a new TS file was added or was deleted, then we should do a sass update
            return sass_1.sassUpdate(event, filePath, context);
        }
    }).then(function () {
        logger.finish();
    }).catch(function (err) {
        if (err instanceof logger_1.IgnorableError) {
            throw err;
        }
        throw logger.fail(err);
    });
}
