"use strict";
var config_1 = require('./util/config');
var logger_1 = require('./util/logger');
var bundle_1 = require('./bundle');
var path_1 = require('path');
var fs_1 = require('fs');
var sass_1 = require('./sass');
var build_1 = require('./build');
function templateUpdate(event, filePath, context) {
    var logger = new logger_1.Logger('template update');
    return templateUpdateWorker(event, filePath, context)
        .then(function () {
        logger.finish();
    })
        .catch(function (err) {
        if (err instanceof logger_1.IgnorableError) {
            throw err;
        }
        throw logger.fail(err);
    });
}
exports.templateUpdate = templateUpdate;
function templateUpdateWorker(event, filePath, context) {
    logger_1.Logger.debug("templateUpdate, event: " + event + ", path: " + filePath);
    if (event === 'change') {
        if (context.bundler === config_1.BUNDLER_WEBPACK) {
            logger_1.Logger.debug("templateUpdate: updating webpack file");
            var typescriptFile = getTemplatesTypescriptFile(context, filePath);
            if (typescriptFile && typescriptFile.length > 0) {
                return build_1.buildUpdate(event, typescriptFile, context);
            }
        }
        else if (updateBundledJsTemplate(context, filePath)) {
            logger_1.Logger.debug("templateUpdate, updated js bundle, path: " + filePath);
            return Promise.resolve();
        }
    }
    logger_1.Logger.debug('templateUpdateWorker: Can\'t update template, doing a full rebuild');
    // not sure how it changed, just do a full rebuild without the bundle cache
    context.useBundleCache = false;
    return bundle_1.bundleUpdate(event, filePath, context)
        .then(function () {
        context.useSassCache = true;
        return sass_1.sassUpdate(event, filePath, context);
    })
        .catch(function (err) {
        if (err instanceof logger_1.IgnorableError) {
            throw err;
        }
        throw new logger_1.BuildError(err);
    });
}
function inlineTemplate(sourceText, sourcePath) {
    var componentDir = path_1.parse(sourcePath).dir;
    var match;
    var replacement;
    var lastMatch = null;
    while (match = getTemplateMatch(sourceText)) {
        if (match.component === lastMatch) {
            // panic! we don't want to melt any machines if there's a bug
            logger_1.Logger.debug("Error matching component: " + match.component);
            return sourceText;
        }
        lastMatch = match.component;
        if (match.templateUrl === '') {
            logger_1.Logger.error("Error @Component templateUrl missing in: \"" + sourcePath + "\"");
            return sourceText;
        }
        replacement = updateTemplate(componentDir, match);
        if (replacement) {
            sourceText = sourceText.replace(match.component, replacement);
        }
    }
    return sourceText;
}
exports.inlineTemplate = inlineTemplate;
function updateTemplate(componentDir, match) {
    var htmlFilePath = path_1.join(componentDir, match.templateUrl);
    try {
        var templateContent = fs_1.readFileSync(htmlFilePath, 'utf8');
        return replaceTemplateUrl(match, htmlFilePath, templateContent);
    }
    catch (e) {
        logger_1.Logger.error("template error, \"" + htmlFilePath + "\": " + e);
    }
    return null;
}
exports.updateTemplate = updateTemplate;
function replaceTemplateUrl(match, htmlFilePath, templateContent) {
    var orgTemplateProperty = match.templateProperty;
    var newTemplateProperty = getTemplateFormat(htmlFilePath, templateContent);
    return match.component.replace(orgTemplateProperty, newTemplateProperty);
}
exports.replaceTemplateUrl = replaceTemplateUrl;
function updateBundledJsTemplate(context, htmlFilePath) {
    logger_1.Logger.debug("updateBundledJsTemplate, start: " + htmlFilePath);
    var outputDest = bundle_1.getJsOutputDest(context);
    try {
        var bundleSourceText = fs_1.readFileSync(outputDest, 'utf8');
        var newTemplateContent = fs_1.readFileSync(htmlFilePath, 'utf8');
        bundleSourceText = replaceBundleJsTemplate(bundleSourceText, newTemplateContent, htmlFilePath);
        if (bundleSourceText) {
            fs_1.writeFileSync(outputDest, bundleSourceText, { encoding: 'utf8' });
            logger_1.Logger.debug("updateBundledJsTemplate, updated: " + htmlFilePath);
            return true;
        }
    }
    catch (e) {
        logger_1.Logger.debug("updateBundledJsTemplate error: " + e);
    }
    return false;
}
function getTemplatesTypescriptFile(context, templatePath) {
    try {
        var srcDirName = path_1.dirname(templatePath);
        var files = fs_1.readdirSync(srcDirName);
        var typescriptFilesNames = files.filter(function (file) {
            return path_1.extname(file) === '.ts';
        });
        for (var _i = 0, typescriptFilesNames_1 = typescriptFilesNames; _i < typescriptFilesNames_1.length; _i++) {
            var fileName = typescriptFilesNames_1[_i];
            var fullPath = path_1.join(srcDirName, fileName);
            var fileContent = fs_1.readFileSync(fullPath).toString();
            var isMatch = tryToMatchTemplateUrl(fileContent, fullPath, srcDirName, templatePath);
            if (isMatch) {
                return fullPath;
            }
        }
        return null;
    }
    catch (ex) {
        logger_1.Logger.debug('getTemplatesTypescriptFile: Error occurred - ', ex.message);
        return null;
    }
}
function tryToMatchTemplateUrl(fileContent, filePath, componentDirPath, templateFilePath) {
    var lastMatch = null;
    var match;
    while (match = getTemplateMatch(fileContent)) {
        if (match.component === lastMatch) {
            // panic! we don't want to melt any machines if there's a bug
            logger_1.Logger.debug("Error matching component: " + match.component);
            return false;
        }
        lastMatch = match.component;
        if (!match.templateUrl || match.templateUrl === '') {
            logger_1.Logger.error("Error @Component templateUrl missing in: \"" + filePath + "\"");
            return false;
        }
        var templatUrlPath = path_1.resolve(path_1.join(componentDirPath, match.templateUrl));
        if (templatUrlPath === templateFilePath) {
            return true;
        }
    }
    return false;
}
function replaceBundleJsTemplate(bundleSourceText, newTemplateContent, htmlFilePath) {
    var prefix = getTemplatePrefix(htmlFilePath);
    var startIndex = bundleSourceText.indexOf(prefix);
    if (startIndex === -1) {
        return null;
    }
    var suffix = getTemplateSuffix(htmlFilePath);
    var endIndex = bundleSourceText.indexOf(suffix, startIndex + 1);
    if (endIndex === -1) {
        return null;
    }
    var oldTemplate = bundleSourceText.substring(startIndex, endIndex + suffix.length);
    var newTemplate = getTemplateFormat(htmlFilePath, newTemplateContent);
    var lastChange = null;
    while (bundleSourceText.indexOf(oldTemplate) > -1 && bundleSourceText !== lastChange) {
        lastChange = bundleSourceText = bundleSourceText.replace(oldTemplate, newTemplate);
    }
    return bundleSourceText;
}
exports.replaceBundleJsTemplate = replaceBundleJsTemplate;
function getTemplateFormat(htmlFilePath, content) {
    // turn the template into one line and espcape single quotes
    content = content.replace(/\r|\n/g, '\\n');
    content = content.replace(/\'/g, '\\\'');
    return getTemplatePrefix(htmlFilePath) + "'" + content + "'" + getTemplateSuffix(htmlFilePath);
}
exports.getTemplateFormat = getTemplateFormat;
function getTemplatePrefix(htmlFilePath) {
    return "template:/*ion-inline-start:\"" + path_1.resolve(htmlFilePath) + "\"*/";
}
function getTemplateSuffix(htmlFilePath) {
    return "/*ion-inline-end:\"" + path_1.resolve(htmlFilePath) + "\"*/";
}
function getTemplateMatch(str) {
    var match = COMPONENT_REGEX.exec(str);
    if (match) {
        return {
            start: match.index,
            end: match.index + match[0].length,
            component: match[0],
            templateProperty: match[3],
            templateUrl: match[5].trim()
        };
    }
    return null;
}
exports.getTemplateMatch = getTemplateMatch;
var COMPONENT_REGEX = /Component\s*?\(\s*?(\{([\s\S]*?)(\s*templateUrl\s*:\s*(['"`])(.*?)(['"`])\s*?)([\s\S]*?)}\s*?)\)/m;
